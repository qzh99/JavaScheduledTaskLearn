# 平衡二叉堆

### 【引言】

在计算机科学中，堆（Heap）是一种基于树（Tree）的特殊的数据结构。堆需要满足堆特性（Heap Property）：如果节点 A 是节点 B 的父节点，则节点 A 中的键值与节点 B 中的键值的比较顺序关系将适用于堆中的所有节点。也就是可以总结为两种情况。

- 父节点的键值大于等于子节点的键值 A(Parent(i)) ≥ A[i] ，则根节点的键值为堆中的最大值。这种类型的堆叫做最大堆（Max Heap）。
- 父节点的键值小于等于子节点的键值 A(Parent(i)) ≤ A[i]，则根节点的键值为堆中的最小值。这种类型的堆叫做最小堆（Min Heap）。

### 【什么是堆】

由于**堆中的最大值或最小值总是被存储在根节点（Root Node）中，所以名字称为堆**。堆不是一种排序的数据结构，可认为是部分排序的结构。从堆的图形结构来看，在相同层级中的节点间没有任何特定的关系，即使是兄弟节点。

### 【应用场景】

堆经常被应用于优先队列（Priority Queue），当你需要找到队列中最高优先级或者最低优先级的元素时，使用堆结构可以帮助你快速的定位元素。

### 【堆实现与基本操作】

常见的堆实现为二叉堆（Binary Heap），其实际上是一颗二叉树（Binary Tree），并且是一颗完全二叉树（Complete Binary Tree）。如下图中展示了一个完全二叉的最大堆。

![输入图片说明](D:\Github\JavaScheduledTaskLearn\JdkTimer\src\main\java\timer\Binary heap.assets\26232836_XxRr.png)

当堆被实现为完全二叉树时，其高度为最小高度。如果堆中有 n 个节点，则最小高度为 Θ(lg n)。

实现堆结构时通常使用数组结构（Array），并且元素间不需要指针引用。使用完全二叉树或者满二叉树实现堆时可以保持最优的空间效率。通常第一个元素或最后一个元素将保存根节点，根节点后紧跟着其两个子节点，两个子节点后将紧跟着 4 个这两个子节点的子节点，以此类推。因此，在一个以 0 为起点的数组中，位置 i 处的节点的子节点的位置将位于 2i+1 和 2i+2 处。平衡一个堆的操作将使用元素互换的方式，所以对堆进行排序无需使用额外的空间，堆排序（heapsort）即是用了这种就地排序（In-Place）的方式。

堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。二叉堆数据结构是一种数组对象，它可以被视为一棵完全二叉树。树中每个节点与数组中存放该节点值的那个元素对应。在堆排序算法中，我们使用最大堆。

### 【堆节点的访问】

通常堆是通过一维数组来实现的。在数组起始为 0 的情形中，如果 i 为当前节点的索引，则有

- 父节点在位置 floor((i-1)/2)；
- 左子节点在位置 (2*i+1)；
- 右子节点在位置 (2*i+2)；

### 【堆的操作】

在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：

- **最大堆调整（Max-Heapify）**：将堆的末端子节点作调整，使得子节点永远小于父节点，保持最大堆性质的关键。运行时间为 O(lg n)。
- **创建最大堆（Build-Max-Heap）：**在无序的输入数组基础上构造出最大堆。运行时间为 O(n)。
- **堆排序（HeapSort）**：对一个数组进行原地排序，卸载位在第一个数据的根节点，并做最大堆调整的递归运算。运行时间为 O(n*lg n)。
- **抽取最大值（Extract-Max）**：相当于执行一次最大堆调整，最大值在根处。运行时间为 O(lg n)。



## 出处

https://my.oschina.net/jimilee/blog/738565